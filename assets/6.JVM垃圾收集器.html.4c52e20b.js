import{_ as e,V as r,W as s,X as l,a0 as a,Z as n,$ as t,Y as d,y as o}from"./framework.591e63b2.js";const c="/assets/java/jvm/gc/collectors.png",h="/assets/java/jvm/gc/serial-old.png",_="/assets/java/jvm/gc/parallel-old.png",u="/assets/java/jvm/gc/cms.png",p="/assets/java/jvm/gc/g1.png",g={},m=d('<p><img src="'+c+'" alt="collectors" loading="lazy"></p><h2 id="一、新生代" tabindex="-1"><a class="header-anchor" href="#一、新生代" aria-hidden="true">#</a> 一、新生代</h2><h3 id="_1-1-serial" tabindex="-1"><a class="header-anchor" href="#_1-1-serial" aria-hidden="true">#</a> 1.1. Serial</h3><ul><li>单线程</li><li>复制算法、新生代</li><li>串行，必须暂停其他所有的工作线程，直到垃圾收集结束</li><li>Client 模式下默认的新生代垃圾收集器</li></ul><h3 id="_1-2-parnew" tabindex="-1"><a class="header-anchor" href="#_1-2-parnew" aria-hidden="true">#</a> 1.2. ParNew</h3><ul><li>多线程</li><li>复制算法、新生代</li><li>串行，必须暂停其他所有的工作线程，直到垃圾收集结束</li><li>启用CMS时，默认的新生代回收器</li><li>Server 模式下新生代的默认垃圾收集器</li></ul><h3 id="_1-3-parallel-scavenge" tabindex="-1"><a class="header-anchor" href="#_1-3-parallel-scavenge" aria-hidden="true">#</a> 1.3. Parallel Scavenge</h3><ul><li>多线程</li><li>复制算法、新生代</li><li>主要关注的是垃圾回收时的吞吐量，而不是尽可能地缩短垃圾收集时用户线程的停顿时间，适合需要与用户交互的程序</li><li>分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis</li><li>设置吞吐量大小的-XX：GCTimeRatio</li></ul><h2 id="二、老年代" tabindex="-1"><a class="header-anchor" href="#二、老年代" aria-hidden="true">#</a> 二、老年代</h2><h3 id="_2-1-serial-old" tabindex="-1"><a class="header-anchor" href="#_2-1-serial-old" aria-hidden="true">#</a> 2.1. Serial Old</h3><ul><li>单线程</li><li>标记整理、老年代</li><li>JDK 5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用</li><li>作为 CMS 收集器发生失败时的后备预案，在并发收集发生 Concurrent Mode Failure 时使用</li><li>Client 默认的 java 虚拟机默认的年老代垃圾收集器</li></ul><p><img src="'+h+'" alt="serial-old" loading="lazy"></p><h3 id="_2-2-parallel-old" tabindex="-1"><a class="header-anchor" href="#_2-2-parallel-old" aria-hidden="true">#</a> 2.2. Parallel Old</h3><ul><li>多线程</li><li>标记整理</li><li>吞吐量优先</li></ul><p><img src="'+_+'" alt="parallel-old" loading="lazy"></p><h3 id="_2-3-cms" tabindex="-1"><a class="header-anchor" href="#_2-3-cms" aria-hidden="true">#</a> 2.3. CMS</h3><ul><li>多线程</li><li>标记清楚、老年代</li><li>是一种以获取最短回收停顿时间为目标的收集器</li></ul><p>从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：</p><ol><li>初始标记：此时会暂停用户线程</li><li>并发标记</li><li>重新标记：此时会暂停用户线程</li><li>并发清除</li><li>重置线程</li></ol><p><img src="'+u+'" alt="cms" loading="lazy"></p><h2 id="三、g1收集器" tabindex="-1"><a class="header-anchor" href="#三、g1收集器" aria-hidden="true">#</a> 三、G1收集器</h2>',21),v=l("ol",null,[l("li",null,"初始标记"),l("li",null,"并发标记"),l("li",null,"最终标记"),l("li",null,[a("筛选回收 "),l("img",{src:p,alt:"g1",loading:"lazy"})])],-1);function f(x,C){const i=o("RouterLink");return r(),s("div",null,[m,l("p",null,[a("G1是一款面向服务端应用的垃圾收集器。 它将整个JVM堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。 这里《深入理解Java虚拟机》提到了记录集和写入屏障，但没细讲，在这篇文章里有："),n(i,{to:"/java/JVM/GC%E8%AF%A6%E8%A7%A3/4.%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html"},{default:t(()=>[a("《分代垃圾回收》")]),_:1}),a("。 如果不计算维护记录集的操作，G1收集器的运作大致可划分为以下几个步骤：")]),v])}const E=e(g,[["render",f],["__file","6.JVM垃圾收集器.html.vue"]]);export{E as default};
