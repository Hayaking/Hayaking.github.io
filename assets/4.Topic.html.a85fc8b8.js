import{_ as t,V as n,W as i,X as e,$ as l,Y as r,y as s}from"./framework.1bd1ad73.js";const a={},c=e("h2",{id:"一、什么是topic",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#一、什么是topic","aria-hidden":"true"},"#"),l(" 一、什么是Topic")],-1),d=e("p",null,"topic是一个存储消息的逻辑概念，是一堆消息的集合。",-1),_=e("h2",{id:"二、topic的组成",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#二、topic的组成","aria-hidden":"true"},"#"),l(" 二、Topic的组成")],-1),h=e("p",null,"topic是由多个分区(partition)组成的，消息要往哪个分区存储是由生产者决定的。",-1),p=e("p",null,"多个分区包含一个topic所有的消息，而这多个分区还有属于自己的副本分区负责冗余存储。",-1),u=e("p",null,"负责冗余存储的副本分区叫做Follower，负责读写的叫做Leader，相关概念如下所示:",-1),f=e("li",null,"AR（Assigned Replicas：）一个partition的所有副本",-1),R=e("li",null,"Leader： 负责读写的分区",-1),m=e("li",null,"Follower ：负责冗余存储的分区",-1),S={href:"http://replica.lag.time.max.ms",target:"_blank",rel:"noopener noreferrer"},I=e("li",null,"ISR（In-Sync Replicas）：能够和 leader 保持同步的 follower + leader本身 组成的集合。",-1),x=e("li",null,"OSR（Out-Sync Replicas）：不能和 leader 保持同步的 follower 集合 AR=ISR+OSR",-1),w=e("h2",{id:"三、isr的作用是什么",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#三、isr的作用是什么","aria-hidden":"true"},"#"),l(" 三、ISR的作用是什么?")],-1),k=e("p",null,"先来看以下问题：",-1),T=e("ul",null,[e("li",null,"1、生产者生产消息的时候，到底要写入多少副本才能算成功呢？"),e("li",null,"2、当leader挂了之后，我们应该选择哪个follower来成为新的leader呢？")],-1),b=e("p",null,"通过ISR，我们知道了哪些follower与leader保持着同步，那么：",-1),g=e("ul",null,[e("li",null,"我们就可以在写入消息的时候，设置写入处于ISR中所有的副本才算成功，"),e("li",null,"我们在进行leader切换的时候，就可以从ISR中选择对应的follower成为新的leader。 这就是ISR的作用：是通过副本机制实现消息高可靠，服务高可用时，不可缺少的一环；这也是为什么讲到副本不得不提到ISR的原因。")],-1);function L(O,V){const o=s("ExternalLinkIcon");return n(),i("div",null,[c,d,_,h,p,u,e("ol",null,[f,R,m,e("li",null,[e("a",S,[l("replica.lag.time.max.ms"),r(o)]),l("： follower与leader同步延迟时间。在指定时间内完成同步的分区会被算作ISR，否则算作OSR")]),I,x]),w,k,T,b,g])}const y=t(a,[["render",L],["__file","4.Topic.html.vue"]]);export{y as default};
