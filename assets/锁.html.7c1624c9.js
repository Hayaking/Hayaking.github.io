import{_ as s,V as l,W as i,Y as a,Z as e,$ as o,X as c,y as d}from"./framework.7aad78ec.js";const t={},r=c(`<h2 id="全局锁" tabindex="-1"><a class="header-anchor" href="#全局锁" aria-hidden="true">#</a> 全局锁</h2><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>flush <span class="token keyword">tables</span> <span class="token keyword">with</span> <span class="token keyword">read</span> <span class="token keyword">lock</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行后，<mark>整个数据库就处于只读状态了</mark>，这时其他线程执行以下操作，都会被阻塞：</p><ul><li>对数据的增删改操作，比如 insert、delete、update等语句；</li><li>对表结构的更改操作，比如 alter table、drop table 等语句</li></ul><p>如果要释放全局锁，则要执行这条命令：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">unlock</span> <span class="token keyword">tables</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="表级锁" tabindex="-1"><a class="header-anchor" href="#表级锁" aria-hidden="true">#</a> 表级锁</h2><ul><li>表锁；</li><li>元数据锁（MDL）;</li><li>意向锁；</li><li>AUTO-INC 锁</li></ul><h3 id="表锁" tabindex="-1"><a class="header-anchor" href="#表锁" aria-hidden="true">#</a> 表锁</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">--表级别的共享锁，也就是读锁；</span>
<span class="token keyword">lock</span> <span class="token keyword">tables</span> t_student <span class="token keyword">read</span><span class="token punctuation">;</span>

<span class="token comment">--表级别的独占锁，也就是写锁；</span>
<span class="token keyword">lock</span> <span class="token keyword">tables</span> t_stuent <span class="token keyword">write</span><span class="token punctuation">;</span>

<span class="token comment">--释放表锁</span>
<span class="token keyword">unlock</span> <span class="token keyword">tables</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="元数据锁-mdl" tabindex="-1"><a class="header-anchor" href="#元数据锁-mdl" aria-hidden="true">#</a> 元数据锁（MDL）</h3><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是 MDL 读锁；</li><li>对一张表做结构变更操作的时候，加的是 MDL 写锁</li></ul><h3 id="意向锁" tabindex="-1"><a class="header-anchor" href="#意向锁" aria-hidden="true">#</a> 意向锁</h3><p>InnoDB支持多粒度的锁共存，它允许表级锁、行级锁共存。</p><p>意向锁的存在就是为了协调行锁和表锁的关系，支持行锁表锁共存，它是一种不与行锁冲突的表级锁。</p><ul><li>在使用 InnoDB 引擎的表里对一些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li><li>在使用 InnoDB 引擎的表里对一些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」</li></ul><p>通俗的讲，就是在给行级别的数据加锁时，会自动的给表加一个意向锁，目的是为了告诉其它事务，这张表里的一些数据被上了锁，省去了遍历数据去得知数据有没有加锁的操作，达到快速判断表里是否有记录被加锁。</p><h3 id="auto-inc-锁" tabindex="-1"><a class="header-anchor" href="#auto-inc-锁" aria-hidden="true">#</a> AUTO-INC 锁</h3><p>表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。</p><p>AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。 但是，在进行大量数据插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。 因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增。</p><p>InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p><ul><li>当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；</li><li>当 innodb_autoinc_lock_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。</li><li>当 innodb_autoinc_lock_mode = 1： <ul><li>普通 insert 语句，自增锁在申请之后就马上释放；</li><li>类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li></ul></li></ul><h2 id="行级锁" tabindex="-1"><a class="header-anchor" href="#行级锁" aria-hidden="true">#</a> 行级锁</h2><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p><p>普通的 select 语句是不会对记录加锁的，因为它属于<mark>快照读</mark>。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为<mark>锁定读（当前读）</mark></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 对读取的记录加共享锁</span>
<span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>

<span class="token comment">-- 对读取的记录加独占锁</span>
<span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面加锁的语句必须在事务中</p><p>细分的话，行级锁的类型主要有三类：</p><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li><li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul><h3 id="record-lock" tabindex="-1"><a class="header-anchor" href="#record-lock" aria-hidden="true">#</a> Record Lock</h3><p>刚刚上面讲的就是Record Lock</p><h3 id="gap-lock" tabindex="-1"><a class="header-anchor" href="#gap-lock" aria-hidden="true">#</a> Gap Lock</h3><p>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p><p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。</p><h3 id="next-key-lock" tabindex="-1"><a class="header-anchor" href="#next-key-lock" aria-hidden="true">#</a> Next-Key Lock</h3><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p>`,37),p={href:"https://blog.csdn.net/lucky_ly/article/details/125252075",target:"_blank",rel:"noopener noreferrer"};function k(u,h){const n=d("ExternalLinkIcon");return l(),i("div",null,[r,a("p",null,[e("具体锁的范围，参考："),a("a",p,[e("https://blog.csdn.net/lucky_ly/article/details/125252075"),o(n)])])])}const v=s(t,[["render",k],["__file","锁.html.vue"]]);export{v as default};
