import{_ as a,V as e,W as i,X as r}from"./framework.7aad78ec.js";const h={},l=r('<h2 id="标记-压缩算法" tabindex="-1"><a class="header-anchor" href="#标记-压缩算法" aria-hidden="true">#</a> 标记-压缩算法</h2><blockquote><p>GC 标记 - 压缩算法（Mark Compact GC）是将 GC 标记 - 清除算法与 GC 复制算 法相结合的产物。</p></blockquote><h2 id="一、lisp2算法" tabindex="-1"><a class="header-anchor" href="#一、lisp2算法" aria-hidden="true">#</a> 一、Lisp2算法</h2><p>标记阶段与标记-清除算法一样，压缩阶段就是让有用的对象覆盖掉没用的对象，这比复制算法好，不用牺牲半个堆空间。 完成该算法实现，至少要遍历3次堆：</p><ol><li>找到有用的对象前面没用的对象</li><li>移动指针</li><li>移动对象。</li></ol><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点:</h3><p>可有效利用堆</p><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点：</h3><p>遍历三次堆不好，存在还进的空间。</p><h2 id="二、two-finger算法" tabindex="-1"><a class="header-anchor" href="#二、two-finger算法" aria-hidden="true">#</a> 二、Two-Finger算法</h2><blockquote><p>这是一种高效的算法，具体来说就是需要搜索 2 次堆。 Two-Finger 算法有着很大的制约条件，那就是“必须将所有对象整理成大小一致”。之前介绍的算法都没有这种限制，而 Two -Finger 算法就必须严格遵守这个制约条件。原因我们会在之后的内容中进行说明。</p></blockquote><p>该算法的实现就是将List2算法的第一次遍历与第三次遍历合并，找到没用的对象后直接拿有用的对象替换它。这样一来不仅不需要存储没用的对象指针，也可以使遍历次数减少为两次：</p><ol><li>移动对象</li><li>更新指针</li></ol><h3 id="优点-1" tabindex="-1"><a class="header-anchor" href="#优点-1" aria-hidden="true">#</a> 优点：</h3><p>相较于List2算法，即减少了时间，也减少了空间。</p><h3 id="缺点-1" tabindex="-1"><a class="header-anchor" href="#缺点-1" aria-hidden="true">#</a> 缺点：</h3><ol><li>制约条件，那就是“必须将所有对象整理成大小一致</li><li>无法保证有引用关系的对象在堆内相邻，所以无法使用缓存技术。</li></ol><h2 id="三、表格算法" tabindex="-1"><a class="header-anchor" href="#三、表格算法" aria-hidden="true">#</a> 三、表格算法</h2><blockquote><p>这个算法和 Two-Finger 算法一样，都是执行 2 次压缩操作。</p></blockquote><p>表格算法通过以下 2 个步骤来执行压缩：</p><ol><li>移动对象（群）以及构筑间隙表格（break table）</li><li>更新指针</li></ol><h3 id="优点-2" tabindex="-1"><a class="header-anchor" href="#优点-2" aria-hidden="true">#</a> 优点：</h3><ol><li>没有必要为压缩准备出多余的空间</li><li>保证有引用关系的对象在堆内相邻，可以使用缓存技术</li></ol><h3 id="缺点-2" tabindex="-1"><a class="header-anchor" href="#缺点-2" aria-hidden="true">#</a> 缺点：</h3><p>维护表格的代价比较大</p>',25),d=[l];function o(t,n){return e(),i("div",null,d)}const s=a(h,[["render",o],["__file","标记清楚算法.html.vue"]]);export{s as default};
