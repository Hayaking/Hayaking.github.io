import{_ as e,V as i,W as l,a0 as a}from"./framework.1bd1ad73.js";const s="/assets/knowledge/操作系统/零拷贝/1.png",t="/assets/knowledge/操作系统/零拷贝/2.png",n="/assets/knowledge/操作系统/零拷贝/3.png",r="/assets/knowledge/操作系统/零拷贝/4.png",d="/assets/knowledge/操作系统/零拷贝/5.png",p={},o=a('<h2 id="一、为什么需要零拷贝" tabindex="-1"><a class="header-anchor" href="#一、为什么需要零拷贝" aria-hidden="true">#</a> 一、为什么需要零拷贝</h2><p>如下图所示，用户进程发起read()系统调用从磁盘读取，CPU发起IO然后交由DMA，DMA将数据从磁盘缓冲区拷贝到内核缓冲区，然后CPU又将数据从内核缓冲区复制到了用户态的用户缓冲区。这中间发生了两次拷贝。</p><p><img src="'+s+'" alt="" loading="lazy"></p><p>如果此时用户进程想把read进来的数据通过网络write给远方的进程了，那么流程如下图所示:</p><p><img src="'+t+'" alt="" loading="lazy"></p><p>可以看到，数据从用户态拷贝到了内核态socket缓冲区，DMA又将缓冲区里的数据拷贝到了网卡。。。。</p><p>可以看到，一次read、一次write，导致了：</p><ul><li>两次系统调用</li><li>两次用户态切内核态</li><li>两次内核态切用户态</li><li>四次数据拷贝</li></ul><p>要想提高性能、就要减少系统调用、减少内存拷贝次数。零拷贝就是这么做的。</p><h2 id="二、mmap-write" tabindex="-1"><a class="header-anchor" href="#二、mmap-write" aria-hidden="true">#</a> 二、mmap + write</h2><p>mmap直接将内核缓存映射到用户态的进程中（流程如下），从而避免了一次用户态到内核态的数据拷贝。 <img src="'+n+'" alt="" loading="lazy"></p><p>此时：</p><ul><li>两次系统调用</li><li>两次用户态切内核态</li><li>两次内核态切用户态</li><li>三次数据拷贝</li></ul><p>只是减少了一次拷贝。能不能减少的再多点？当然可以</p><h2 id="三、sendfile" tabindex="-1"><a class="header-anchor" href="#三、sendfile" aria-hidden="true">#</a> 三、sendfile</h2><p>使用sendfile系统调用，可以让cpu直接将数据从内核缓冲区拷贝到另一个内核缓冲区，从而避免了两次系统调用 <img src="'+r+'" alt="" loading="lazy"></p><p>此时：</p><ul><li>sendfile一次系统调用</li><li>一次用户态切内核态</li><li>一次内核态切用户态</li><li>三次数据拷贝</li></ul><h2 id="四、sg-dma" tabindex="-1"><a class="header-anchor" href="#四、sg-dma" aria-hidden="true">#</a> 四、SG-DMA</h2><p>网卡支持 SG-DMA 技术，那么sendfile会在减少一次数据拷贝，数据不会再在内核态的缓冲区之间拷贝了，而是直接由SG-DMA把内核态的缓冲区里的数据拷贝至网卡的缓冲区里。如下图所示：</p><p><img src="'+d+'" alt="" loading="lazy"></p><p>此时：</p><ul><li>sendfile一次系统调用</li><li>一次用户态切内核态</li><li>一次内核态切用户态</li><li>两次数据拷贝</li></ul>',23),c=[o];function h(_,m){return i(),l("div",null,c)}const f=e(p,[["render",h],["__file","零拷贝.html.vue"]]);export{f as default};
