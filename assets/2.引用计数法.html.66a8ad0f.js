import{_ as e,V as a,W as t,Y as c}from"./framework.591e63b2.js";const o="/assets/java/jvm/gc/gc-ref.png",i={},r=c('<h2 id="_1-引用计数算法" tabindex="-1"><a class="header-anchor" href="#_1-引用计数算法" aria-hidden="true">#</a> 1. 引用计数算法</h2><blockquote><p>引用计数法中引入了一个概念，那就是“计数器”。计数器表示的是对象的人气指数， 也就是有多少程序引用了这个对象（被引用数）。计数器是无符号的整数，用于计数器的位数根据算法和实现而有所不同。</p></blockquote><p><img src="'+o+'" alt="collectors" loading="lazy"></p><p>被引用的对象不仅自己计数器要加1，其自己包含的引用的对象的计数器也要加1。</p><h2 id="_2-延迟引用计数法" tabindex="-1"><a class="header-anchor" href="#_2-延迟引用计数法" aria-hidden="true">#</a> 2.延迟引用计数法</h2><p>引用计数法的缺点就是计数器值的增减处理繁重。 这里就引入了延迟引用计数法，延迟就是先不计数，等时机到了再计数。 引入一个 ZCT（Zero Count Table）表，来引用那些引用为0的对象。 被ZCT引用的对象可能不是垃圾。 当ZCT满时就遍历ZCT引用的对象，开始计算每一个对象被引用的值，计算完后回收那些引用依然为0的对象，剩下的就是有用的对象，再把它们的引用值清零。</p><h2 id="_3-sticky引用计数法" tabindex="-1"><a class="header-anchor" href="#_3-sticky引用计数法" aria-hidden="true">#</a> 3.Sticky引用计数法</h2><p>该方法主要是觉得计数器的值用int类型有点浪费，推荐使用位数少的的数据类型来存储。书上是这样说的：</p><blockquote><p>计数器需要 1 个字（32 位机器就是 32 位）的空间。但是这样会大量消耗内存空间。 对此我们有个方法，那就是用来减少计数器位宽的“Sticky 引用计数法”。举个例子，我们假设用于计数器的位数为 5 位，那么这种计数器最多只能数到 2 的 5 次方减 1，也就是 31个引用数。如果此对象被大于 31 个对象引用，那么计数器就会溢出。这跟车辆速度计的指针爆表是一个状况。 针对计数器溢出（也就是爆表的对象），需要暂停对计数器的管理。对付这种对象，我们主要有两种方法。</p></blockquote><p>两种方法是：</p><ol><li>什么都不做 在快要溢出时，不再增加引用值，避免溢出。因为这样的概率太小，绝大多数对象的引用值不会超过1。</li><li>采用标记-清除法辅助。。。</li></ol>',11),_=[r];function s(l,n){return a(),t("div",null,_)}const h=e(i,[["render",s],["__file","2.引用计数法.html.vue"]]);export{h as default};
