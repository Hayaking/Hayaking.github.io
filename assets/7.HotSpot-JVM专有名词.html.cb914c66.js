import{_ as n,V as l,W as d,X as e,$ as a,Y as t,Z as h,a0 as r,y as o}from"./framework.1bd1ad73.js";const c={},s=r('<h2 id="一、stw" tabindex="-1"><a class="header-anchor" href="#一、stw" aria-hidden="true">#</a> 一、STW</h2><p>Stop The World。即在gc时，JVM中的用户线程全部暂停的场景。</p><h2 id="二、根节点枚举" tabindex="-1"><a class="header-anchor" href="#二、根节点枚举" aria-hidden="true">#</a> 二、根节点枚举</h2><p>列出所有GCRoot</p><p>所有收集器在根节点枚举这一步骤时都是必须STW</p><h2 id="三、oopmap" tabindex="-1"><a class="header-anchor" href="#三、oopmap" aria-hidden="true">#</a> 三、OopMap</h2><p>OopMap(Ordinary Object Pointer Map)，存储栈上的对象引用的信息。</p><p>在根节点枚举时，只需要遍历每个栈桢的 OopMap，通过 OopMap 存储的信息，快捷地找到 GC Roots</p><p>OopMap 中存储了两种对象的引用：</p><ul><li>栈里和寄存器内的引用。在jit中，在特定的位置记录下栈里和寄存器里哪些位置是引用</li><li>对象内的引用。类加载动作完成时，HotSpot 就会计算出对象内什么偏移量上是什么类型的数据</li></ul><blockquote><p>注：把存储单元的实际地址与其所在段的段地址之间的距离称为段内偏移，也称为有效地址或偏移量，因此，实际地址=所在段的起始地址+偏移量</p></blockquote><ul><li>一个线程为一个栈</li><li>一个栈由多个栈桢组成</li><li>一个栈桢对应一个方法</li><li>一个栈帧可能有多个 OopMap</li></ul><h2 id="三、安全点" tabindex="-1"><a class="header-anchor" href="#三、安全点" aria-hidden="true">#</a> 三、安全点</h2><p>安全点（Safe Point）。如果每一条语句都去操作oopMap，那么会较低程序执行效率，因此引入了Safe Point的概念。，只有在到达Safe Point时才会操作OopMap。</p><p>Safe Point时线程执行过程中的一些特殊位置，当线程执行到 Safe Point 的时候，线程可以暂停, 保存当前线程有哪些对象、使用了哪些内存信息到OopMap。</p><blockquote><p>interrupted 也是根据 Safe Point 实现的。当我们在代码里写入 Thread.interrupt() 时，只有线程运行到 Safe Point 处时才知道是否发生了 interrupted</p></blockquote><h2 id="四、安全区" tabindex="-1"><a class="header-anchor" href="#四、安全区" aria-hidden="true">#</a> 四、安全区</h2><p>安全区（Safe Region）。安全点有个问题就是，当有线程处于阻塞状态，例如sleep了好长时间，一直无法继续向下执行代码，那么这个线程就会一直无法到达安全点。</p><p>针对这个问题，又引入了安全区的概念。在安全区中，对象的引用关系不会变，因此可以认为在安全区中任意一次开始GC都是安全的。</p><h2 id="五、记忆集" tabindex="-1"><a class="header-anchor" href="#五、记忆集" aria-hidden="true">#</a> 五、记忆集</h2><p>分代垃圾回收机制中记录跨代引用的。</p>',21),u=r(`<p>记忆集的实现可以有多种，以精度区分：</p><ul><li>字长精度：每个记录精确到一个机器字长，该字包含跨代引用。</li><li>对象精度：每个记录精确到对象，该对象里有字段含跨代引用。</li><li>区域精度（卡精度）：每个记录精确到一块内存区域，该内存区域有对象含有跨代引用。</li></ul><h2 id="六、卡表" tabindex="-1"><a class="header-anchor" href="#六、卡表" aria-hidden="true">#</a> 六、卡表</h2><p>卡表（Card Table）就是记忆集卡精度的实现方案。</p><p>HotSpot虚拟机卡表的实现是一个字节数组：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CARD_TABLE [] = 0;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>CARD_TABLE[i]代表着一块内存区域，这块内存区域叫做<mark>卡页（Card Page）</mark>，HotSpot中卡页大小默认2^9=512字节。</p><ul><li>CARD_TABLE[i]==0时，表示对应的内存区域没有跨代引用</li><li>CARD_TABLE[i]==1时，表示对应的内存区域存在跨代引用</li></ul><blockquote><p>在垃圾回收时，只需要筛选出卡表中等于1的，就能得到哪些卡页内存块中包含跨代指针，从而将它们加入GC Roots中一并扫描。</p></blockquote><h2 id="七、写屏障" tabindex="-1"><a class="header-anchor" href="#七、写屏障" aria-hidden="true">#</a> 七、写屏障</h2><p>JVM是在何时操作记忆集（卡表）的呢？即写屏障(Write Barrier)。</p><p>在给对象进行赋值操作时，会给赋值操作前后加上两个操作：</p><ul><li>写前屏障（Pre-Write Barrier）</li><li>写后屏障（Post-Write Barrier）</li></ul><p>在写后屏障中，会对卡表进行操作，去维护跨带引用的关系。</p><blockquote><p>开启有条件的卡表操作: -XX:+UseCondCardMark, 开启后，在写后屏障时会判断所在的Card Page是否已经存在跨代引用，如果已存在跨带引用，就不操作卡表。避免虚共享</p></blockquote><h2 id="八、虚共享" tabindex="-1"><a class="header-anchor" href="#八、虚共享" aria-hidden="true">#</a> 八、虚共享</h2><p>上面提到了一个虚共享的玩意。</p><p>应该是说类似卡表的实现上应用了volatile的机制，当前线程的写操作导致了其它线程的<mark>缓存中的卡表数据失效</mark>，使得其它线程去内存中读取卡表的数据。增加了不必要的cpu读取内存的操作，降低了程序执行效率。</p><p>所以还是把<code>-XX:+UseCondCardMark</code>开开吧。</p>`,19),E={href:"https://luolanmeet.github.io/jvm-note/content/part2/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/%E5%86%99%E5%B1%8F%E9%9A%9C.html",target:"_blank",rel:"noopener noreferrer"};function _(f,b){const i=o("RouterLink"),p=o("ExternalLinkIcon");return l(),d("div",null,[s,e("p",null,[a("参考"),t(i,{to:"/java/JVM/gc/4.%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html"},{default:h(()=>[a("4.分代垃圾回收")]),_:1})]),u,e("p",null,[e("a",E,[a("参考"),t(p)])])])}const B=n(c,[["render",_],["__file","7.HotSpot-JVM专有名词.html.vue"]]);export{B as default};
