import{_ as s,V as t,W as l,X as a,a0 as n,Z as c,Y as o,y as r}from"./framework.591e63b2.js";const p={},i=o(`<h2 id="一、threadlocal" tabindex="-1"><a class="header-anchor" href="#一、threadlocal" aria-hidden="true">#</a> 一、ThreadLocal</h2><p>ThreadLocal大家都知道是线程内部传递变量的、一般用在用户信息传递，traceId传递、数据库事务控制等功能的实现上。</p><p>使用起来非常简单</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 新建ThreadLocal</span>
<span class="token keyword">var</span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 可以在当前业务线程生命周期运行的各个位置运行get、set方法存取值</span>
threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;hahaha&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> v <span class="token operator">=</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 有线程复用的情况的话一定要在线程处理任务结束时remove，防止内存泄漏或下个线程获取这个值造成bug</span>
threadLocal<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-1-threadlocalmap" tabindex="-1"><a class="header-anchor" href="#_1-1-threadlocalmap" aria-hidden="true">#</a> 1.1 ThreadLocalMap</h3><p>每个线程都有一个ThreadLocalMap，在调用ThreadLocal的get、set方法时，回去获取当前线程的ThreadLocalMap，并从中存取值。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// threadlocal内部获取threadLocalMap</span>
<span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ThreadLocalMap是一个哈希表，与jdk的HashMap不同，ThreadLocalMap实现比较简单，没有用链地址法解决hash冲突，也没有红黑树，而是使用线性探测法。</p><h2 id="二、inheritablethreadlocal" tabindex="-1"><a class="header-anchor" href="#二、inheritablethreadlocal" aria-hidden="true">#</a> 二、InheritableThreadLocal</h2><p>ThreadLocal只适用于当前线程内部变量传递，如果要在父子线程传递内部变量就需要用到InheritableThreadLocal。子线程可以通过InheritableThreadLocal获取父线程的内部变量。</p><h3 id="_2-1-inheritablethreadlocalmap" tabindex="-1"><a class="header-anchor" href="#_2-1-inheritablethreadlocalmap" aria-hidden="true">#</a> 2.1 InheritableThreadLocalMap</h3><p>每个线程其实有两个ThreadLocal对象，一个叫threadLocals，另一个叫inheritableThreadLocals。其中threadLocals用来实现当前线程内部变量传递的，inheritableThreadLocals用来实现父子线程传递内部变量的。</p><p>关键代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// thread类在实例化时，会判断父线程的inheritableThreadLocals是否是null</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>inheritThreadLocals <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> parentThread<span class="token punctuation">.</span>inheritableThreadLocals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 不等于null，就拿过来直接用</span>
    inheritableThreadLocals <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">createInheritedMap</span><span class="token punctuation">(</span>parentThread<span class="token punctuation">.</span>inheritableThreadLocals<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>拿到了父线程的inheritableThreadLocals就好办了，InheritableThreadLocal每次从InheritableThreadLocal get就能实现父线程向子线程共享内部变量的作用了。</p><blockquote><p>!! createInheritedMap是深拷贝，子线程修改inheritableThreadLocals，影响不到父线程的</p></blockquote><h2 id="三、fastthreadlocal" tabindex="-1"><a class="header-anchor" href="#三、fastthreadlocal" aria-hidden="true">#</a> 三、FastThreadLocal</h2><p>FastThreadLocal是netty实现的thread，在一个线程有大量内部变量时，读写效率会比JDK自带的ThreadLocal高</p><blockquote><p>netty不仅实现了自己的FastThreadLocal，还实现了自己的ThreadLocalMap、FastThreadLocalThread（netty封装的线程）,这几个要搭配起来使用，不能与JDK原生的混用</p></blockquote><h3 id="_3-1-为什么比threadlocal快" tabindex="-1"><a class="header-anchor" href="#_3-1-为什么比threadlocal快" aria-hidden="true">#</a> 3.1 为什么比ThreadLocal快</h3><p>因为JDK的ThreadLocalMap用的是hash表，在有大量threadLocal的时候就会有hash冲突，这就影响读写内部变量的效率了。</p><p>Netty的ThreadLocalMap内部用的不是hash表，而是用数组直接存的内部变量。每个FastThreadLocal会维护一个index属性，记录自己在数组种的位置。读场景下，根据FastThreadLocal的index属性直接从数组获取值；写场景下index+1分配给新的FastThreadLocal。这样就省去计算hashcode、数组下标索引、hash冲突的操作，效率上会比jdk的要高。</p><blockquote><p>使用上与jdk的没啥区别</p></blockquote><h2 id="四、transmittablethreadlocal" tabindex="-1"><a class="header-anchor" href="#四、transmittablethreadlocal" aria-hidden="true">#</a> 四、TransmittableThreadLocal</h2><p>这个是阿里开源的一个ThreadLocal实现。用于向线程池里的线程传递内部变量用的。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Main线程 {
    线程A
    
    ---线程池
    线程1
    线程2
    线程3
    ---
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看上面这个场景，线程A在使用线程池时，想把值传递给线程池里的线程，此时用JDK提供的ThreadLocal、InheritableThreadLocal都无法实现，因为ThreadLocal只管当前线程、InheritableThreadLocal只管父子线程。显然线程A与线程池里的线程都不属于这种关系。</p>`,27),d={href:"https://github.com/alibaba/transmittable-thread-local",target:"_blank",rel:"noopener noreferrer"},h=a("p",null,"实现原理大概思路就是：",-1),u=a("ul",null,[a("li",null,"将TransmittableThreadLocal和它的值存到map中"),a("li",null,"然后使用装饰器模式包装Runnable类(TtlRunnable)"),a("li",null,"TtlRunnable获得map的引用，并在runnable的run方法运行前将map中的值set到当前线程中，并保存set之前的备份"),a("li",null,"runnable的run方法执行完后，根据set之前的备份")],-1);function k(b,m){const e=r("ExternalLinkIcon");return t(),l("div",null,[i,a("blockquote",null,[a("p",null,[n("具体使用参考官方github readme: "),a("a",d,[n("https://github.com/alibaba/transmittable-thread-local"),c(e)])])]),h,u])}const T=s(p,[["render",k],["__file","各种ThreadLocal.html.vue"]]);export{T as default};
