import{_ as a,V as e,W as r,X as t}from"./framework.44074f5b.js";const l="/assets/algo/data-structure/black-red-tree/1.png",s="/assets/algo/data-structure/black-red-tree/2.png",i="/assets/algo/data-structure/black-red-tree/3.png",d="/assets/algo/data-structure/black-red-tree/4.png",n="/assets/algo/data-structure/black-red-tree/5.png",c="/assets/algo/data-structure/black-red-tree/6.png",h="/assets/algo/data-structure/black-red-tree/7.png",p="/assets/algo/data-structure/black-red-tree/8.png",o="/assets/algo/data-structure/black-red-tree/9.png",u="/assets/algo/data-structure/black-red-tree/10.png",_="/assets/algo/data-structure/black-red-tree/11.png",g="/assets/algo/data-structure/black-red-tree/12.png",m="/assets/algo/data-structure/black-red-tree/13.png",b="/assets/algo/data-structure/black-red-tree/14.png",f="/assets/algo/data-structure/black-red-tree/15.png",L="/assets/algo/data-structure/black-red-tree/16.png",x="/assets/algo/data-structure/black-red-tree/17.png",k={},R=t('<h1 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h1><p>以前在了解HashMap时得知JDK8的Map是用红黑树实现的（存储元素的链表达到一定长度后，会变为红黑树），而且网上还流传着面试手写红黑树的梗，数据结构课上也没交过这个</p><h1 id="一、为什么要用红黑树" tabindex="-1"><a class="header-anchor" href="#一、为什么要用红黑树" aria-hidden="true">#</a> 一、为什么要用红黑树</h1><p>因为相较于普通的二叉搜索树，红黑树具有平衡性。这与AVL树相似，在增加或删除元素后可能会出现旋转的操作。 但是相较于AVL树严格的约束（左右子树的高度之差的绝对值最多为1），红黑树的平衡约束更为宽松，其旋转操作的时间复杂度为O(1)，而AVL树的旋转操作的时间复杂度为O(log n)。 因此在做增加、删除操作时可以选择红黑树，而在做搜索操作时选择AVL树（因为严格的平衡性，高度一般比红黑树低）。</p><h1 id="二、定义" tabindex="-1"><a class="header-anchor" href="#二、定义" aria-hidden="true">#</a> 二、定义</h1><blockquote><p>红黑树（Red Black Tree） 是一种自平衡二叉查找树。</p></blockquote><h1 id="三、性质" tabindex="-1"><a class="header-anchor" href="#三、性质" aria-hidden="true">#</a> 三、性质</h1><p><img src="'+l+'" alt="" loading="lazy"></p><ol><li>节点是红色或黑色</li><li>根节点必须是黑色</li><li>叶子节点（null节点）必须是黑色</li><li><mark>红色节点的子节点都是黑色的，红色节点的父节点是黑色的</mark></li><li>从根节点起到叶子节点的所有路径中，不能有两个连续的红色节点</li><li>从根节点起到叶子节点的所有路径中，黑色节点的个数都是相同的</li></ol><p>为了方便起见，后面省略null节点</p><h1 id="四、操作" tabindex="-1"><a class="header-anchor" href="#四、操作" aria-hidden="true">#</a> 四、操作</h1><h2 id="_1-搜索" tabindex="-1"><a class="header-anchor" href="#_1-搜索" aria-hidden="true">#</a> 1.搜索</h2><p>同二叉搜索树一样，差不了多少，从根节点比大小，走分支</p><h2 id="_2-添加" tabindex="-1"><a class="header-anchor" href="#_2-添加" aria-hidden="true">#</a> 2.添加</h2><p>添加操作比较复杂，情况比较多。</p><p>添加的节点本身都是红色，为了区别开来，这里都用粉红色代表新添加的节点。</p><h3 id="_2-1-添加到黑色节点" tabindex="-1"><a class="header-anchor" href="#_2-1-添加到黑色节点" aria-hidden="true">#</a> 2.1.添加到黑色节点</h3><p><img src="'+s+'" alt="" loading="lazy"> 这是最简单的一种情况，粉红色的为新添加的节点，其父节点为黑色，不违反性质4，所以不需要旋转。</p><h3 id="_2-2-添加到红色节点" tabindex="-1"><a class="header-anchor" href="#_2-2-添加到红色节点" aria-hidden="true">#</a> 2.2.添加到红色节点</h3><p><img src="'+i+'" alt="" loading="lazy"> 出现了红色节点的子节点是红色的情况，违反性质4、5，所以需要旋转。</p><ul><li>LL型 uncle节点为黑</li><li>RR型 uncle节点为黑</li><li>LR型 uncle节点为黑</li><li>RL型 uncle节点为黑</li><li>LL型 uncle节点为红色</li><li>RR型 uncle节点为红色</li><li>LR型 uncle节点为红色</li></ul><h4 id="_2-2-1-ll型-uncle节点为黑" tabindex="-1"><a class="header-anchor" href="#_2-2-1-ll型-uncle节点为黑" aria-hidden="true">#</a> 2.2.1.LL型 uncle节点为黑</h4><p><img src="'+d+'" alt="" loading="lazy"></p><p>如图，新增节点60，是76左孩子的左孩子，这种类型被称之为LL型，显然LL型是不符合性质4的。 此时需要<mark>右旋</mark>，将72变黑，76变红，同时72变为76的父节点，即可满足性质4。 如果60有兄弟节点，则将其移动到祖节点76的下面。</p><p><img src="'+n+'" alt="" loading="lazy"></p><h4 id="_2-2-2-rr型-uncle节点为黑" tabindex="-1"><a class="header-anchor" href="#_2-2-2-rr型-uncle节点为黑" aria-hidden="true">#</a> 2.2.2.RR型 uncle节点为黑</h4><p><img src="'+c+'" alt="" loading="lazy"></p><p>如图，新增节点52，是46右孩子的右孩子，这种类型被称之为RR型，显然RR型是不符合性质4的。 此时<strong>左旋</strong>，将50变黑，46变红，同时50变为46的父节点，即可满足性质4。 <img src="'+h+'" alt="" loading="lazy"></p><h4 id="_2-2-3-lr型-uncle节点为黑" tabindex="-1"><a class="header-anchor" href="#_2-2-3-lr型-uncle节点为黑" aria-hidden="true">#</a> 2.2.3.LR型 uncle节点为黑</h4><p><img src="'+p+'" alt="" loading="lazy"></p><p>旋转后，新增的子节点74变为黑色，父节点和祖父节点变为红色作为74的子节点</p><p><img src="'+o+'" alt="" loading="lazy"></p><h4 id="_2-2-4-rl型-uncle节点为黑" tabindex="-1"><a class="header-anchor" href="#_2-2-4-rl型-uncle节点为黑" aria-hidden="true">#</a> 2.2.4.RL型 uncle节点为黑</h4><p><img src="'+u+'" alt="" loading="lazy"></p><p>旋转后，新增的子节点48变为黑色，父节点和祖父节点变为红色作为74的子节点</p><p><img src="'+_+'" alt="" loading="lazy"></p><h4 id="_2-2-5-ll型-uncle节点为红色" tabindex="-1"><a class="header-anchor" href="#_2-2-5-ll型-uncle节点为红色" aria-hidden="true">#</a> 2.2.5.LL型 uncle节点为红色</h4><p><img src="'+g+'" alt="" loading="lazy"></p><p>将父节点，叔节点变黑，祖节点变红，如下图：</p><p><img src="'+m+'" alt="" loading="lazy"></p><p>会发现，此时已然不符合性质4，但是25、38、55符合2.2.1的LL型，右旋即可。</p><h4 id="_2-2-6-rr型-uncle节点为红色" tabindex="-1"><a class="header-anchor" href="#_2-2-6-rr型-uncle节点为红色" aria-hidden="true">#</a> 2.2.6.RR型 uncle节点为红色</h4><p><img src="'+b+'" alt="" loading="lazy"></p><p>变色后</p><p><img src="'+f+'" alt="" loading="lazy"></p><p>符合2.2.1的LL型，右旋即可</p><h4 id="_2-2-7-lr型-uncle节点为红色" tabindex="-1"><a class="header-anchor" href="#_2-2-7-lr型-uncle节点为红色" aria-hidden="true">#</a> 2.2.7.LR型 uncle节点为红色</h4><p><img src="'+L+'" alt="" loading="lazy"></p><p>变色后：</p><p><img src="'+x+'" alt="" loading="lazy"></p><p>符合2.2.1的LL型，右旋即可</p><h4 id="_2-2-7-rl型-uncle节点为红色" tabindex="-1"><a class="header-anchor" href="#_2-2-7-rl型-uncle节点为红色" aria-hidden="true">#</a> 2.2.7.RL型 uncle节点为红色</h4><p>......</p><h2 id="_3-删除" tabindex="-1"><a class="header-anchor" href="#_3-删除" aria-hidden="true">#</a> 3.删除</h2><h3 id="_3-1-删除度为2的黑色节点" tabindex="-1"><a class="header-anchor" href="#_3-1-删除度为2的黑色节点" aria-hidden="true">#</a> 3.1 删除度为2的黑色节点</h3><p>找该节点的前驱或后继替换掉该节点。</p><h3 id="_3-2-删除拥有一个红色子节点的黑色节点" tabindex="-1"><a class="header-anchor" href="#_3-2-删除拥有一个红色子节点的黑色节点" aria-hidden="true">#</a> 3.2 删除拥有一个红色子节点的黑色节点</h3><p>找该节点的前驱或后继替换掉该节点，然后染黑。</p><h3 id="_3-3-删除度为0的黑色节点" tabindex="-1"><a class="header-anchor" href="#_3-3-删除度为0的黑色节点" aria-hidden="true">#</a> 3.3 删除度为0的黑色节点</h3><h4 id="_3-3-1-兄弟节点是黑色且有红色子节点" tabindex="-1"><a class="header-anchor" href="#_3-3-1-兄弟节点是黑色且有红色子节点" aria-hidden="true">#</a> 3.3.1 兄弟节点是黑色且有红色子节点</h4><p>删除该节点，然后旋转、染色。</p><h4 id="_3-3-2-兄弟节点是黑色且无红色子节点" tabindex="-1"><a class="header-anchor" href="#_3-3-2-兄弟节点是黑色且无红色子节点" aria-hidden="true">#</a> 3.3.2 兄弟节点是黑色且无红色子节点</h4><p>将兄弟节点染成红色，父节点染成黑色。</p><h3 id="_3-4-删除红色节点" tabindex="-1"><a class="header-anchor" href="#_3-4-删除红色节点" aria-hidden="true">#</a> 3.4 删除红色节点</h3><p>直接删除</p><p>。。。。。。。太麻烦了。。。。。。。。。。。。。。。。。。。。。。。。。。不想写了</p>',66),y=[R];function z(V,A){return e(),r("div",null,y)}const q=a(k,[["render",z],["__file","红黑树.html.vue"]]);export{q as default};
