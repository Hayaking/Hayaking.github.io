import{_ as l,V as i,W as e,Y as a}from"./framework.591e63b2.js";const r={},h=a('<h2 id="一、什么是进程" tabindex="-1"><a class="header-anchor" href="#一、什么是进程" aria-hidden="true">#</a> 一、什么是进程</h2><p>进程是：</p><ul><li>一次程序的执行</li><li>程序及其数据在计算机上执行所发生的活动</li><li>时操作系统分配资源和调度的一个独立单位</li></ul><p>进程分为内核进程、用户进程：</p><ul><li>内核进程：就是操作系统内核，在开机时，磁盘中的内核程序加载进内存，成为内核进程</li><li>用户进程：一般讲的进程就是用户进程，就是应用程序的执行过程。</li></ul><h3 id="_1-1-pcb" tabindex="-1"><a class="header-anchor" href="#_1-1-pcb" aria-hidden="true">#</a> 1.1 PCB</h3><p>创建进程实质上是创建进程实体中的PCB（进程控制块），系统利用PCB描述和记录进程的基本情况和活动记录。</p><p>PCB包含以下信息：</p><ul><li>进程标识符: <ul><li>外部标识符</li><li>内部标识符</li></ul></li><li>处理机状态</li><li>进程调度信息</li><li>进程控制信息</li></ul><p>PCB组织管理方式：</p><ul><li>线性方式：相当于用数组管理PCB</li><li>链接方式：相当于链表，根据进程的状态，会有三种不同的链表实现的队列（就绪队列、执行队列、阻塞队列）</li><li>索引方式：根据进程的状态，开几个数组，数组记录PCB的地址</li></ul><h3 id="_1-2-进程的状态" tabindex="-1"><a class="header-anchor" href="#_1-2-进程的状态" aria-hidden="true">#</a> 1.2 进程的状态</h3><ul><li>就绪：分配好出CPU以外的必要资源后，其PCB会被放到就绪队列中</li><li>执行：获取到CPU后，其PCB会被放到执行队列中</li><li>阻塞：进程发生IO请求、申请缓冲区失败等暂时无法继续执行的操作时，就会阻塞。其PCB会被系统挪到阻塞队列中</li></ul><p>进程状态切换：</p><ul><li>就绪-&gt;执行：被调度，获取到CPU</li><li>执行-&gt;就绪：时间片用完</li><li>执行-&gt;阻塞: IO阻塞...</li><li>阻塞-&gt;就绪: IO完成...</li></ul><h3 id="_1-3-进程间通信方式" tabindex="-1"><a class="header-anchor" href="#_1-3-进程间通信方式" aria-hidden="true">#</a> 1.3 进程间通信方式</h3><ul><li>管道</li><li>消息队列</li><li>共享内存</li><li>信号量</li><li>信号</li><li>socket</li></ul><h2 id="二、什么是线程" tabindex="-1"><a class="header-anchor" href="#二、什么是线程" aria-hidden="true">#</a> 二、什么是线程</h2><p>早期的操作系统中都是以进程作为独立运行的基本单位，后来人们提出了比进程更小的进本单位----线程。</p><p>线程拥有传统进程所拥有的特征，所以又被称之为轻量级进程。初期以进程作为基本调度和分派单位时，都需要进行较大开销的上下文切换。而以线程作为基本调度和分派单位时，上下文切换的开销远低于进程，仅需保存和设置少量寄存器内容。</p><h3 id="_2-1-tcb" tabindex="-1"><a class="header-anchor" href="#_2-1-tcb" aria-hidden="true">#</a> 2.1 TCB</h3><p>每个进程都有自己的PCB，同样的每个线程有自己的TCB（线程控制块）。</p><p>线程控制块用于记录控制管理线程的信息。</p><p>TCB包含以下信息：</p><ul><li>现成标识符</li><li>一组寄存器</li><li>线程状态</li><li>优先级</li><li>线程私有的存储区</li><li>信号屏蔽</li><li>堆栈指针</li></ul><h3 id="_2-2-线程状态" tabindex="-1"><a class="header-anchor" href="#_2-2-线程状态" aria-hidden="true">#</a> 2.2 线程状态</h3><ul><li>就绪状态：除了CPU，其它必要资源都一获得</li><li>执行状态：已经获得CPU且正在执行</li><li>阻塞状态：调用发生阻塞时，处于暂停状态</li></ul><h3 id="_2-3-线程的实现" tabindex="-1"><a class="header-anchor" href="#_2-3-线程的实现" aria-hidden="true">#</a> 2.3 线程的实现</h3><ul><li>内核支持线程KST(kernel support thread)：在内核中实现的线程，是由内核管理的线程</li><li>用户级线程ULT(user level thread)： 在用户空间实现的线程，不是由内核管理的线程</li></ul><blockquote><p>基于ULT、KST可以实现n:1、1:1、n:m线程模型</p></blockquote><ul><li>轻量级进程LWP: LWP通过系统调用获得内核提供的服务，通过LWP把内核、用户级线程连接，同时也实现了隔离</li></ul><blockquote><p>一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度</p></blockquote><p>在 LWP 之上也是可以使用用户线程的，那么 LWP 与用户线程的对应关系就有三种：</p><ul><li>1 : 1，即一个 LWP 对应 一个用户线程；</li><li>N : 1，即一个 LWP 对应多个用户线程；</li><li>M : N，即多个 LWP 对应多个用户线程；</li></ul><h3 id="_2-4-线程间通信方式" tabindex="-1"><a class="header-anchor" href="#_2-4-线程间通信方式" aria-hidden="true">#</a> 2.4 线程间通信方式</h3><ul><li>锁</li><li>信号量</li><li>信号</li></ul>',36),d=[h];function t(u,c){return i(),e("div",null,d)}const p=l(r,[["render",t],["__file","进程和线程.html.vue"]]);export{p as default};
